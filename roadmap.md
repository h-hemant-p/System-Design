System Design Roadmap
--

LLD

Step 1: Object Oriented Programming
    - Encapsulation
    - Abstraction
    - Inheritance
    - Polymorphism
    - SOLID Principles

Step 2: Design Patterns
    - Creational (Singleton, Factory etc.)
    - Structural (Proxy, Bridge etc.)
    - Behavioral (Strategy, Command, Observer etc.)

Step 3: Concurrency & Thread Safety
    - Thread safe injection
    - Locking mechanisms
    - producer-consumer
    - race conditions & synchronization
    
Step 4: UML Digrams

Step 5: APIs
    - API Design
    - req/res object modeling
    - Versioning & extensibility
    - clean code principles: DRY, SRP etc.
    - Avoiding God classes

Step 6: Common LLD Problems
    - 1. Design a Tic-tac-toe or chess game
    - 2. Design s Splitwise App
    - 3. Design a Parking lot
    - 4. Design an Elevator System with multiple Lifts
    - 5. Design a Notification System
    - 6. Design a Food delivery App
    - 7. Design a Movie ticket booking system
    - 8. Design a URL Shortener
    - 9. Design a Logging Framework
    - 10. Design a Rate Limiter

--

HLD

Step 1: Fundamentals
    - Serverless vs Serverful
    - Hirizontal vs Vertical Scaling
    - What are threads?
    - What are pages?
    - How does the internet work?

Step 2: Databases
    - SQL vs NoSQL
    - In-Memory Databases
    - Data Replication and Migration
    - Data Partitioning
    - Sharding

Step 3: Consistency vs Availability
    - Data Consistency & its levels
    - Isolation and its levels
    - CAP Theorem

Step 4: Caching
    - What is Cache? (Redis, Memcached)
    - Write Policies: write back, through & around
    - Replacement Policies: LRU, LFU, Segregated LRU etc.
    - Content Delivery Network (CDN)

Step 5: Networking
    - TCP vs UDP
    - What is http (1/2/3) & https
    - Web Sockets
    - WebRTC & video streaming

Step 6: Load Balancing
    - Load Balancing Algorithms (Stateless vs Stateful)
    - Consistent Hashing
    - Proxy and Reverse Proxy
    - Rate Limiting

Step 7: Message Queues
    - Asynchronous Processing (Kafka, RabbitMQ)
    - Publisher-Subscriber Model

Step 8: Monolithic vs Microservices
    - Why Microservices?
    - Concept of 'Single Point of Failure'
    - Avoiding Cascading Failures
    - Containerization (Docker)
    - Migration to Microservices

Step 9: Monitoring and Logging
    - Logging events & monitoring metrics
    - Anomaly Detection

Step 10: Security
    - Tokens for auth
    - SSO & OAuth
    - Access Control Lists & Rule Engines
    - Encryption

Step 11: System Design Tradeoffs
    - Push vs Pull Architecture
    - Consistency vs Availability
    - SQl vs NoSQL
    - Memory vs Latency
    - Throughput vs Latency
    - Accuracy vs Latency

Step 12: Practice
